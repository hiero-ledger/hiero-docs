# 虚拟投票

仅仅确保每个成员都知道每一个事件是不够的。 还需要\
来商定事件的线性订单，从而同意事件内记录的\
交易。 没有\
领导的大部分Byzantine 故障容忍协议依赖于成员相互发送票。 .其中一些\
协议需要每个人的票据。 。而且他们的\
可能需要多轮投票，这进一步增加了投票\
信息发送的次数。

这种纯粹的投票办法使得在一个规模较大的网络中的带宽过于宽泛和不切实际，但具有达成共识的最公平和最安全的方法的特点。 哈希图算法实现了同样的公平和安全属性，但也很快和实用。 它通过**虚拟投票**实现了这一点。

哈希图算法不需要通过网络发送任何票数来计算每个成员的票数。 会员可以通过内部查看每个会员的散列图并应用虚拟投票算法来计算其他会员的票数。 投票按特定事件的祖先在当地计算。

这种虚拟投票有若干好处。 除了保存带宽外，它还确保成员总是按照规则计算他们的票数。 如果艾丽斯是诚实的，她将计算虚拟机器人诚实的虚拟投票。 即使真正的机器人是作弊者，他也不能通过虚拟机器人的投票错误来攻击艾丽斯。

通过这个虚拟投票算法，Byzantine 协议得到保证。

虚拟投票在三个步骤中发生：

1. 分割响铃
2. 决定自己的名字
3. 查找订单

## 分割响铃

为了开始虚拟表决进程，我们必须首先界定几轮投票和证人。 在哈希图历史中，成员节点的第一个事件是节点的第一个**见证人**。 第一位证人是该节点的第一轮\(r\)开始。 所有随后发生的事件都是第一轮事件的一部分，直到发现新的证人为止。 当节点创建一个新的事件时发现了一名证人，可以**强烈地看到**2张证人\*\*3张。 例如， 事件w可以强烈地看到事件x，当w w可以通过父关系追踪其祖先时，父关系会经过至少居住在成员节点2级的其他事件。 如果某一事件决心强烈地看到本轮证人中的2位正直证人， 这一事件被视为该节点的下一个见证人。 该新见证人是该节点的下一轮\(r+1\)的第一个事件。 当事件被添加到哈希图形时，每个事件都被分配了一个圆形。

```text
procedure divideRounds

for each event x
    r <- max round of parents of x (or 1 if none exist)
    if x can strongly see more than 2n/3 round r witnesses
        x.round <- r+1
    else
      x.round <- r
    x.witness <- (x has no self parent)
                or (x.round > x.selfParent.round)
```

## 决定自己的名字

下一步是决定证人是否是著名证人。 如果许多证人能够在下一轮中看到它，证人就会闻名，如果许多人能够看到它，就不会闻名。 如果事件B是事件A的祖先，则事件A可以\*\*见事件B。 在决定证人A的名子时，我们必须看看下一轮的证人。 如果下一轮证人可以看见证人A，他们算作支持证人A的票数。 同样，如果下一轮证人不能见到证人A，那么证人的投票就是证人A不闻名。 为了让证人A被视为著名人士， 未来的证人必须能够有力地看到至少有2名投票证人投票赞成著名证人A。 如果2名投票证人中有3名证人投票认为证人A不知名，那么证人A将被裁定不知名。

## 查找订单

现在我们已经计算出一个回合的所有目击者都是著名或非著名的， 我们可以确定在著名证人事件之前发生的事件的顺序。 这是通过计算完成的：

1. **一轮收到了**所有尚未下令的事件\*\*，这些事件是在决定所有证人的名字之前发生的。 事件收到的一轮是第一轮，所有著名的证人都可以看到\(或是有关事件的后代)。
2. 每个事件**时间戳**。 这是通过召集所收到的一轮著名证人的最早祖先，他们也是有关事件的后代。 并占用收集到的事件的中位时间戳。
3. **排序事件** 首先是：回合收到协商一致的时间戳，然后签署。
